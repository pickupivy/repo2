许多有用的算法在结构上是递归的：为了解决一个特定的问题，算法一次或多次递归地调用其自身以解决相关的若干子问题。这些算法典型地遵循分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解得到原问题的解。
	堆排序，集合了插入排序和归并排序的优点：
与归并排序一样，堆排序的时间复杂度是O(nlgn)，优于插入排序；
与插入排序一样，堆排序具有空间原址性，即任何时候都只需要常数个额外的元素空间存储临时数据。

插入排序、归并排序、堆排序、快速排序这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。这类排序算法统称为比较排序。对包含n个元素的输入序列来说，任何比较排序在最坏情况下都要经过Ω(nlgn)次比较，因此，归并排序和堆排序是渐进最优的，并且任何已知的比较排序最多就是在常数因子上优于它们。

在n个元素中同时找到最小值和最大值的方法，最直观的是：只要分别独立地找出最小值和最大值，这各需要n-1次比较，共需2n-2次比较。但事实上，我们只需要最多3[n/2]次比较就可以同时找到最小值和最大值。首先，将一对输入元素相互进行比较，然后较小的值与当前最小值比较，较大值与当前最大值进行比较。这样，对每两个元素共需3次比较。
差别在于，第一种方法，输入一个数后进行了两次比较，但相应的录入只有一次(即录入最大值的话，与最小值的比较就相当于无用功)。

(二叉)堆是一个数组，可以看作一个近似的完全二叉树，树上的每一个节点对应数组中的一个元素。表示堆的数组A包括两个属性：A.length给出数组元素的个数，A.heap-size表示堆中存放的有效元素的个数？
对于一个给定的下表i，可以计算它的父节点、左孩子和右孩子的下标：
(#define)	PARENT(i)	return	[i/2]		//向下取整(左移一位运算)
(#define)	LEFT(i)		return	2i		//右移一位运算
(#define)	RIGHT(i)		return	2i+1
在最大堆中，最大堆性质是指除了根节点以外的所有节点i都要满足：
A[PARENT(i)]≥A[i],	即某个节点的值至多与其父节点一样大，堆中的最大元素存放在根节点中，任一子树所包含的所有节点的值都不大于该子树根节点的值。最小堆性质刚好相反。
A[PARENT(i)]≤A[i]
定义：一个堆中节点的高度就是该节点到叶节点最长简单路径上边的数目；进而我们定义堆的高度为根节点的高度。
