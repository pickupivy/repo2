sfr也是一种扩充数据类型，点用一个内存单元，值域为0～255。利用它可以访问51单片机内部的所有特殊功能寄存器。如用sfr P1 = 0x90这一句定P1为P1端口在片内的寄存器，在后面的语句中我们用以用P1 = 255（对P1端口的所有引脚置高电平）之类的语句来操作特殊功能寄存器。
sfr P1 = 0x90; //定义P1 I/O 口,其地址90H
sfr 关键定后面是一个要定义的名字,可任意选取,但要符合标识符的命名规则,名字最好有一定的含义如P1 口可以用P1 为名,这样程序会变的好读好多.等号后面必须是常数,不允许有带运算符的表达式,而且该常数必须在特殊功能寄存器的地址范围之内(80H-FFH),具体可查看附录中的相关表.
sfr 是定义8 位的特殊功能寄存器而sfr16 则是用来定义16 位特殊功能寄存器,
如8052 的T2 定时器,可以定义为:
sfr16 T2 = 0xCC; //这里定义8052 定时器2,地址为T2L=CCH,T2H=CDH
用sfr16 定义16 位特殊功能寄存器时,等号后面是它的低位地址,高位地址一定要位于物
理低位地址之上.注意的是不能用于定时器0 和1 的定义.
sbit 可定义可位寻址对象.如访问特殊功能寄存器中的某位.其实这样应用是经常要
用的如要访问P1 口中的第2 个引脚P1.1.我们可以照以下的方法去定义:
(1) sbit 位变量名=位地址
sbit P1_1 = Ox91;
这样是把位的绝对地址赋给位变量.同sfr 一样sbit 的位地址必须位于80H-FFH 之间.
(2) sbit 位变量名=特殊功能寄存器名^位位置
sft P1 = 0x90;
sbit P1_1 = P1 ^ 1; //先定义一个特殊功能寄存器名再指定位变量名所在的位置,当可
寻址位位于特殊功能寄存器中时可采用这种方法
(3) sbit 位变量名=字节地址^位位置
sbit P1_1 = 0x90 ^ 1;
这种方法其实和2 是一样的,只是把特殊功能寄存器的位址直接用常数表示. 在C51
存储器类型中提供有一个bdata 的存储器类型,这个是指可位寻址的数据存储器,位于单
片机的可位寻址区中,可以将要求可位录址的数据定义为bdata,如:
unsigned char bdata ib; //在可位录址区定义ucsigned char 类型的变量ib
int bdata ab[2]; //在可位寻址区定义数组ab[2],这些也称为可寻址位对象
sbit ib7=ib^7 //用关键字sbit 定义位变量来独立访问可寻址位对象的其中一位
sbit ab12=ab[1]^12;
操作符"^"后面的位位置的最大值取决于指定的基址类型,char0-7,int0-15,long0-31.
sfr 并标准C 语言的关键字，而是Keil 为能直接访问80C51 中的SFR 而提供了一个新
的关键词，其用法是：
sfrt 变量名=地址值。
2）符号P1_0 来表示P1.0 引脚。
在C 语言里，如果直接写P1.0，C 编译器并不能识别，而且P1.0 也不是一个合法的C
语言变量名，所以得给它另起一个名字，这里起的名为P1_0，可是P1_0 是不是就是P1.0
呢？你这么认为，C 编译器可不这么认为，所以必须给它们建立联系，这里使用了Keil C
的关键字sbit 来定义，sbit 的用法有三种：
第一种方法：sbit 位变量名＝地址值
第二种方法：sbit 位变量名＝SFR 名称^变量位地址值
第三种方法：sbit 位变量名＝SFR 地址值^变量位地址值
如定义PSW 中的OV 可以用以下三种方法：
sbit OV=0xd2 （1）说明：0xd2 是OV 的位地址值
sbit OV=PSW^2 （2）说明：其中PSW 必须先用sfr 定义好
sbit OV=0xD0^2 （3）说明：0xD0 就是PSW 的地址值
因此这里用sfr P1_0=P1^0;就是定义用符号P1_0 来表示P1.0 引脚，如果你愿意也可以
起P10 一类的名字，只要下面程序中也随之更改就行了。

